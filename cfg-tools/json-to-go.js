// Sanitizes and formats a string to make an appropriate identifier in Go
function format(str)
{
	if (!str)
		return "";
	else if (str.match(/^\d+$/))
		str = "Num" + str;
	else if (str.charAt(0).match(/\d/))
	{
		var numbers = {'0': "Zero_", '1': "One_", '2': "Two_", '3': "Three_",
			'4': "Four_", '5': "Five_", '6': "Six_", '7': "Seven_",
			'8': "Eight_", '9': "Nine_"};
		str = numbers[str.charAt(0)] + str.substr(1);
	}
	return toProperCase(str).replace(/[^a-z0-9]/ig, "") || "NAMING_FAILED";
}

// Proper cases a string according to Go conventions
function toProperCase(str)
{
	// https://github.com/golang/lint/blob/39d15d55e9777df34cdffde4f406ab27fd2e60c0/lint.go#L695-L731
	var commonInitialisms = [
		"API", "ASCII", "CPU", "CSS", "DNS", "EOF", "GUID", "HTML", "HTTP", 
		"HTTPS", "ID", "IP", "JSON", "LHS", "QPS", "RAM", "RHS", "RPC", "SLA", 
		"SMTP", "SSH", "TCP", "TLS", "TTL", "UDP", "UI", "UID", "UUID", "URI", 
		"URL", "UTF8", "VM", "XML", "XSRF", "XSS"
	];

	return str.replace(/(^|[^a-zA-Z])([a-z]+)/g, function(unused, sep, frag)
	{
		if (commonInitialisms.indexOf(frag.toUpperCase()) >= 0)
			return sep + frag.toUpperCase();
		else
			return sep + frag[0].toUpperCase() + frag.substr(1).toLowerCase();
	}).replace(/([A-Z])([a-z]+)/g, function(unused, sep, frag)
	{
		if (commonInitialisms.indexOf(sep + frag.toUpperCase()) >= 0)
			return (sep + frag).toUpperCase();
		else
			return sep + frag;
	});
}

function jsonToGo(json, typename)
{
	var data;
	var scope;
	var go = "";
	var tabs = 0;

	try
	{
		data = JSON.parse(json.replace(/\.0/g, ".1")); // hack that forces floats to stay as floats
		scope = data;
	}
	catch (e)
	{
		return {
			go: "",
			error: e.message
		};
	}

	typename = format(typename || "AutoGenerated");
	append("type "+typename+" ");

        console.log(typename);
	parseScope(scope);
	
	return { go: go };



	function parseScope(scope)
	{
		if (typeof scope === "object" && scope !== null)
		{
			if (Array.isArray(scope))
			{
				var sliceType, scopeLength = scope.length;

				for (var i = 0; i < scopeLength; i++)
				{
					var thisType = goType(scope[i]);
					if (!sliceType)
						sliceType = thisType;
					else if (sliceType != thisType)
					{
						sliceType = mostSpecificPossibleGoType(thisType, sliceType);
						if (sliceType == "interface{}")
							break;
					}
				}

				append("[]");
				if (sliceType == "struct") {
					var allFields = {};

					// for each field counts how many times appears
					for (var i = 0; i < scopeLength; i++)
					{
						var keys = Object.keys(scope[i])
						for (var k in keys)
						{
							var keyname = keys[k];
							if (!(keyname in allFields)) {
								allFields[keyname] = {
									value: scope[i][keyname],
									count: 0
								}
							}

							allFields[keyname].count++;
						}
					}
					
					// create a common struct with all fields found in the current array
					// omitempty dict indicates if a field is optional
					var keys = Object.keys(allFields), struct = {}, omitempty = {};
					for (var k in keys)
					{
						var keyname = keys[k], elem = allFields[keyname];

						struct[keyname] = elem.value;
						omitempty[keyname] = elem.count != scopeLength;
					}

					parseStruct(struct, omitempty); // finally parse the struct !!
				}
				else if (sliceType == "slice") {
					parseScope(scope[0])
				}
				else
					append(sliceType || "interface{}");
			}
			else
			{
				parseStruct(scope);
			}
		}
		else
			append(goType(scope));
	}

	function parseStruct(scope, omitempty)
	{
		append("struct {\n");
		++tabs;
		var keys = Object.keys(scope);
		for (var i in keys)
		{
			var keyname = keys[i];
			indent(tabs);
			append(format(keyname)+" ");
			parseScope(scope[keyname]);

			append(' `json:"'+keyname);
			if (omitempty && omitempty[keyname] === true)
			{
				append(',omitempty');
			}
			append('"`\n');
		}
		indent(--tabs);
		append("}");
	}

	function indent(tabs)
	{
		for (var i = 0; i < tabs; i++)
			go += '\t';
	}

	function append(str)
	{
		go += str;
	}


	// Determines the most appropriate Go type
	function goType(val)
	{
		if (val === null)
			return "interface{}";
		
		switch (typeof val)
		{
			case "string":
				if (/\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(\.\d+)?(\+\d\d:\d\d|Z)/.test(val))
					return "time.Time";
				else
					return "string";
			case "number":
				if (val % 1 === 0)
				{
					if (val > -2147483648 && val < 2147483647)
						return "int";
					else
						return "int64";
				}
				else
					return "float64";
			case "boolean":
				return "bool";
			case "object":
				if (Array.isArray(val))
					return "slice";
				return "struct";
			default:
				return "interface{}";
		}
	}

	// Given two types, returns the more specific of the two
	function mostSpecificPossibleGoType(typ1, typ2)
	{
		if (typ1.substr(0, 5) == "float"
				&& typ2.substr(0, 3) == "int")
			return typ1;
		else if (typ1.substr(0, 3) == "int"
				&& typ2.substr(0, 5) == "float")
			return typ1;
		else
			return "interface{}";
	}

}

if (typeof module != 'undefined') {
    if (!module.parent) {
        process.stdin.on('data', function(buf) {
            var json = buf.toString('utf8')
            console.log(jsonToGo(json).go)
        })
    } else {
        module.exports = jsonToGo
    }
}
var args = process.argv.splice(2)

if (args.length < 2) {
    console.log("参数不对:json-to-go srcpath destpath");
    process.exit(0)
}

var srcPath = args[0];
var destPath = args[1];
var rf=require("fs");  

var rd = require('rd');
var path=require('path'); 

templateEnd = '\n\n\
func New%sFromConfig() *%s {\n\
	o, err := InitObjectFromFile(New%s(0),"%s.json")\n\
	if err != nil {\n\
		return nil\n\
	}\n\
	p, ok := o.(*%s)\n\
	if ok {\n\
		return p\n\
	}\n\
	return nil\n\
}\n\
\n\
func New%s(id int64) *%s {\n\
	p := &%s{}\n\
	p.Seq = int(id)\n\
	p.TabName = "%s"\n\
	return p\n\
}\n\
\n\
func (p *%s) String() zapcore.Field {\n\
	return zap.Any(p.TabName, p)\n\
}\n\
\n\
func (p *%s) Marshal() ([]byte, error) {\n\
	buff, err := json.Marshal(p)\n\
	if err != nil {\n\
		return nil, err\n\
	}\n\
	return buff, nil\n\
}\n\
\n\
func (p *%s) UnMarshal(buff []byte) (GameObject, error) {\n\
	err := json.Unmarshal(buff, p)\n\
	if err != nil {\n\
		return nil, err\n\
	}\n\
	return p, nil\n\
}\n\
\n\
func (p *%s) GetTime() int64 {\n\
	return int64(p.%sAt)\n\
}\n\
\n\
func (p *%s) SetTime(t int64) {\n\
	p.%sAt = int(t)\n\
}\n\
\n\
func (p *%s) ID() int64 {\n\
	return int64(p.Seq)\n\
}\n\
\n\
func (p *%s) Name() string {\n\
	return p.TabName\n\
}\n\
\n\
func (p *%s) SetID(id int64) {\n\
	p.Seq = int(id)\n\
}\n\
\n\
func (p *%s) Instance(o GameObject, err error) (*%s, error) {\n\
	if err != nil {\n\
		return p, err\n\
	}\n\
	p, ok := o.(*%s)\n\
	if ok {\n\
		return p, nil\n\
	}\n\
	return p, errors.New("%s instance fail")\n\
}\n\
'                                                                            

templateHead = '\n\
package entity\n\
\n\
import (\n\
	"go.uber.org/zap"\n\
	"go.uber.org/zap/zapcore"\n\
	"encoding/json"\n\
	"errors"\n\
)\n\
\n\
'
var util = require('util');
var fs= require("fs");

rd.eachSync("./" + srcPath, function (f, s) {                                     
    // 每找到一个文件都会调用一次此函数
    // 参数s是通过 fs.stat() 获取到的文件属性值
    if (f.endsWith(".json")) {
        console.log('file: %s', f);
        var context = fs.readFileSync(f,'utf-8');
        var myPath = f.replace("json", destPath)
        var pathobj = path.parse(myPath);


        //console.log("pathobj:", pathobj, f.replace("json", "entity"));


        //var destFile = destPath + "/" + pathobj.name + ".go";

        if (!fs.existsSync(pathobj.dir)) {
            fs.mkdirSync(pathobj.dir);
        }
        var resolvePath = path.resolve();
        var destFile = pathobj.dir + "/" + pathobj.name + ".go";
        var pathBeforeName = pathobj.dir.replace(resolvePath, "");
        // console.log(".....", pathBeforeName, ".. ", resolvePath);
        var objName  = format(pathobj.name || "AutoGenerated");
        var lowCaseObjName = pathobj.name;
        var d = JSON.parse(context);
        d[lowCaseObjName + "At"] = 0;
        d["tabName"] = lowCaseObjName;
        var result = jsonToGo(JSON.stringify(d), objName);
        console.log("typename:", objName);
var templateTrans = util.format(templateEnd, objName, objName, objName, pathBeforeName + "/" + lowCaseObjName, objName, objName, objName, objName, lowCaseObjName, objName, objName, objName, objName, objName, objName, objName, objName, objName, objName, objName, objName, objName, objName);
        console.log(destFile);
        fs.writeFileSync(destFile, templateHead + result["go"] + templateTrans); 
    }
});
console.log("操作结束");
process.exit(0);

